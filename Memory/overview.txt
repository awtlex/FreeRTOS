标准库的malloc() free()很可能并不适用于目标板，因为freertOS本身就是用于小型嵌入式系统的
pvPortMalloc() 而不是 malloc()
vPortFree() 而不是 free()

FreeRTOS\source\portable\MemMang\heap_1,2,3,4,5.c
在小型嵌入式系统中，通常是在启动调度器之前创建任务，队列和信号量。这种情
况表明，动态分配内存只会出现在应用程序真正开始执行实时功能之前，而且内存一旦
分配就不会再释放。这就意味着选择内存分配方案时不必考虑一些复杂的因素，比如确
定性与内存碎片等，而只需要从性能上考虑，比如代码大小和简易性。

==============================================================================
heap_1.c
Heap_1.c 实现了一个非常基本的pvPortMalloc()版本，而且没有实现vPortFree()。
如果应用程序不需要删除任务，队列或者信号量，则具有使用heap_1 的潜质。Heap_1
总是具有确定性。
用于从不会删除任务、队列、信号量、互斥量等的应用程序（实际上绝大多数FreeRTOS的应用程序都符合这个条件
执行时间是确定的并且不会产生内存碎片
实现和分配过程非常简单，需要的内存是从一个静态数据中分配的（即适用于那些不进行动态内存分配的应用）
==============================================================================

==============================================================================
Heap_2.c
Heap_2.c 也是使用了一个由configTOTAL_HEAP_SIZE 定义大小的简单数组。不
同于heap_1 的是，heap_2 采用了一个最佳匹配算法(最接近请求大小的空闲内存块)来分配
内存，并且支持内存释放。由于声明了一个静态数组，所以会让整个应用程序看起来耗费了许多
内存——即使是在数组没有进行任何实际分配之前。
Heap_2.c 虽然不具备确定性，但是比大多数标准库实现的malloc()与free()更有效率。
可以用于重复的分配和删除具有相同堆栈空间的任务、队列、信号量、互斥量等，并且不考虑内存碎片的应用程序
不能用在分配和释放随机字节堆栈空间的应用程序
如果你的应用程序中的队列、任务、信号量、互斥量等处在一个不可预料的顺序，则可能会导致内存碎片的问题
==============================================================================

==============================================================================
Heap_3.c
Heap_3.c 简单地调用了标准库函数malloc()和free()，但是通过暂时挂起调度器使得函数调用备线程安全特性
需要链接器设置一个堆栈，并且编译器库提供malloc() free()函数
不具有确定性
可能明显地增大RTOS内核的代码大小
注：heap_3使用时，FreeRTOSConfig.h中的configTOTAL_HEAP_SIZE宏定义没有作用
=============================================================================

=============================================================================
heap_4.c
使用一个最佳匹配算法，但与2不同，会将相邻的空闲内存块合并成一个更大的块
可用于重复分配、删除任务、队列、信号量、互斥量等的应用程序
可以用于分配和释放随机字节内存的情况，并不像heap_2.c产生严重碎片
不具有确定性，但是它比标准库中的malloc函数具有高得多的效率
特别适用于移植层代码，可以直接使用pvPortMalloc() vPortFree()函数来分配和释放内存
=============================================================================

=============================================================================
heap_5.c
这个方案同样实现了heap_4.c中的合并算法，并且允许堆栈跨越多个非连续的内存区
